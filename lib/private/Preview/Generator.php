<?php
/**
 * @copyright Copyright (c) 2016, Roeland Jago Douma <roeland@famdouma.nl>
 *
 * @author Morris Jobke <hey@morrisjobke.de>
 * @author Robin Appelman <robin@icewind.nl>
 * @author Roeland Jago Douma <roeland@famdouma.nl>
 *
 * @license GNU AGPL version 3 or any later version
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

namespace OC\Preview;

use OC\Files\Filesystem;
use OC\Files\View;
use OC\Preview\GeneratorHelper;
use OCP\Files\File;
use OCP\Files\IAppData;
use OCP\Files\NotFoundException;
use OCP\Files\NotPermittedException;
use OCP\Files\SimpleFS\ISimpleFile;
use OCP\Files\SimpleFS\ISimpleFolder;
use OCP\IConfig;
use OCP\IImage;
use OCP\IPreview;
use OCP\Preview\IProvider;
use OCP\Preview\IVersionedPreviewFile;
use OCP\Preview\IProviderV2;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\EventDispatcher\GenericEvent;

class Generator {

	/** @var IPreview */
	private $previewManager;
	/** @var IConfig */
	private $config;
	/** @var IAppData */
	private $appData;
	/** @var GeneratorHelper */
	private $helper;
	/** @var EventDispatcherInterface */
	private $eventDispatcher;

	/**
	 * @param IConfig $config
	 * @param IPreview $previewManager
	 * @param IAppData $appData
	 * @param GeneratorHelper $helper
	 * @param EventDispatcherInterface $eventDispatcher
	 */
	public function __construct(
		IConfig $config,
		IPreview $previewManager,
		IAppData $appData,
		GeneratorHelper $helper,
		EventDispatcherInterface $eventDispatcher
	) {
		$this->config = $config;
		$this->previewManager = $previewManager;
		$this->appData = $appData;
		$this->helper = $helper;
		$this->eventDispatcher = $eventDispatcher;
	}

	/**
	 * Returns a preview of a file
	 *
	 * The cache is searched first and if nothing usable was found then a preview is
	 * generated by one of the providers
	 *
	 * @note: The function name 'getPreview' is not quite good enough, this is
	 *        used to fetch any image.
	 *
	 * @param File $file
	 * @param int $width
	 * @param int $height
	 * @param bool $crop
	 * @param string $mode
	 * @param string $mimeType
	 * @param string $imageGroup
	 *
	 * @return ISimpleFile
	 *
	 * @throws NotFoundException
	 * @throws \InvalidArgumentException if the preview would be invalid (in case the original image is invalid)
	 */
	public function getPreview(File $file, $width = -1, $height = -1, $crop = false, $mode = IPreview::MODE_FILL, $mimeType = null, $imageGroup = false) {

		$preview_width = $width;
		$preview_height = $height;

		//Make sure that we can read the file
		if (!$file->isReadable()) {
			throw new NotFoundException('Cannot read file');
		}

		$this->eventDispatcher->dispatch(
			IPreview::EVENT,
			new GenericEvent($file, [
				'width' => $width,
				'height' => $height,
				'crop' => $crop,
				'mode' => $mode
			])
		);

		if ($mimeType === null) {
			$mimeType = $file->getMimeType();
		}
		if (!$this->previewManager->isMimeSupported($mimeType)) {
			throw new NotFoundException();
		}

		$previewFolder = $this->getPreviewFolder($file);

		$previewVersion = '';
		if ($file instanceof IVersionedPreviewFile) {
			$previewVersion = $file->getPreviewVersion() . '-';
		}

		// Try to get a cached preview. Else generate (and store) one

		try {
			$preview = $this->getCachedPreview($previewFolder, $width, $height, $crop, $file->getMimeType(), $previewVersion);
		} catch (NotFoundException $e) {
			// @todo @dgtlmoon bring back previewVersion
			$preview = $this->generatePreview($previewFolder, $file, $preview_width, $preview_height, $mode, $crop);
		}


		if ($preview->getSize() === 0) {
			$preview->delete();
			throw new NotFoundException('Cached preview size 0, invalid!');
		}

		return $preview;
	}


	/**
	 * @param ISimpleFile $file
	 * @param string $prefix
	 * @return int[]
	 */
	private function getPreviewSize(ISimpleFile $file, string $prefix = '') {
		$size = explode('-', substr($file->getName(), strlen($prefix)));
		return [(int)$size[0], (int)$size[1]];
	}

	private function generatePath($width, $height, $crop, $mimeType, $prefix) {
		$x=1;
	}

	/**
	 * Build the filename usually used for previews.
	 *
	 * @param int $width
	 * @param int $height
	 * @param bool $crop
	 * @param string $mimeType
	 * @param string $prefix
	 * @return string
	 */
	private function generateFilename($width, $height, $crop, $mimeType, $prefix) {
		$path = $prefix . (string)$width . '-' . (string)$height;
		if ($crop) {
			$path .= '-crop';
		}

		$ext = $this->getExtention($mimeType);
		$path .= '.' . $ext;
		return $path;
	}


	/**
	 * Do the actual number crunching behind building the preview/scaled image
	 * and save the subequently created file into the correct/previews/ directory.
	 *
	 * (Thought: maybe pass the DPI info straight here so the server can decide based on configuration?)
	 *
	 * @param ISimpleFolder $previewFolder  - Base dir where to place the preview
	 * @param File $file
	 * @param int $width
	 * @param int $height
	 * @param bool $mode
	 * @param bool $crop
	 *
	 * @return ISimpleFile
	 * @throws NotFoundException
	 * @throws \InvalidArgumentException if the preview would be invalid (in case the original image is invalid)
	 */
	private function generatePreview(ISimpleFolder $previewFolder, File $file, $width, $height, $mode, $crop) {

		if (!$fsize = $file->getSize()) {
			$path = $file->getPath();
			throw new \InvalidArgumentException("Failed to generate preview - File '{$path}' does not exist or appears invalid.");
		}

		$original_full_path =  $file->getStorage()->getLocalFile($file->getInternalPath());

		$img = new \OC_Image();
		$exif_thumb_only = true;
		$img->loadFromFile($original_full_path, $exif_thumb_only);

		// @todo Revisit $prefix.
		$prefix = "";

		// Make the new resized image in memory ready for saving
		if($crop) {
			$img->centerCrop((int)round($width));
		} else {
			$img->preciseResize((int)round($width), (int)round($height));
		}

		// needs to have the leading / ?
		$filename = "/" . $this->generateFilename($width, $height, $crop, $file->getMimeType(), $prefix);
		try {
			$previewFile = $previewFolder->newFile($filename);
			$previewFile->putContent($img->data());
		} catch (NotPermittedException $e) {
			// @wtf - throwing a notpermitted to a notfound is really confusing for everyone.
			throw new NotFoundException();
		}

		return $previewFile;
	}

	/**
	 * @param ISimpleFolder $previewFolder
	 * @param int $width
	 * @param int $height
	 * @param bool $crop
	 * @param string $mimeType
	 * @param string $prefix
	 * @return ISimpleFile
	 *
	 * @throws NotFoundException
	 */
	private function getCachedPreview(ISimpleFolder $previewFolder, $width, $height, $crop, $mimeType, $prefix) {
		$filename = $this->generateFilename($width, $height, $crop, $mimeType, $prefix);

		return $previewFolder->getFile($filename);
	}

	/**
	 * Get the specific preview folder for this file
	 *
	 * @param File $file
	 * @return ISimpleFolder
	 */
	private function getPreviewFolder(File $file) {
		try {
			$folder = $this->appData->getFolder($file->getId());
		} catch (NotFoundException $e) {
			$folder = $this->appData->newFolder($file->getId());
		}

		return $folder;
	}

	/**
	 * @param string $mimeType
	 * @return null|string
	 * @throws \InvalidArgumentException
	 */
	private function getExtention($mimeType) {
		switch ($mimeType) {
			case 'image/png':
				return 'png';
			case 'image/jpeg':
				return 'jpg';
			case 'image/gif':
				return 'gif';
			default:
				throw new \InvalidArgumentException('Not a valid mimetype');
		}
	}
}
